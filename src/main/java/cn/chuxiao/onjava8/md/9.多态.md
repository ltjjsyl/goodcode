#多态
也称为动态绑定或后期绑定或运行时绑定

----------
----------
#向上转型

----------
#方法调用绑定
将一个方法调用和一个方法主体关联起来称作绑定  
若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定  
在运行时根据对象的类型进行绑定，叫做后期绑定，也称为动态绑定或运行时绑定

当一种语言实现了后期绑定，就必须具有某种机制在运行时能判断对象的类型，从而调用恰当的方法  
也就是说，编译器仍然不知道对象的类型，但是方法调用机制能找到正确的方法体并调用  
每种语言的后期绑定机制都不同，但是可以想到，对象中一定存在某种类型信息  

Java中除了static（构造器也是static方法）和final方法（private方法也是隐式的final）外，其他所有方法都是后期绑定  
这意味着通常情况下，不需要判断后期绑定是否会发生——它自动发生

只有普通的方法调用可以是多态的

任何属性访问都被编译器解析，因此不是多态的
Sub extends Super
Super sup = new Sub();
sup.filed;//访问的是Super的属性
这种情况一般不存在，父子类中有相同名称的public属性
Super.field和Sub.field被分配了不同的存储空间，因此，Sub实际上包含了两个称为field的属性：它自己的和来自Super的  
然而，在引用Sub的field时，默认的field属性并不是Super版本的field属性，为了获取Super的field属性，需要显式地指明super.field。

方法是静态(static)的，它的行为就不具有多态性：静态的方法只与类关联，与单个的对象无关  

final，它有效地”关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。这可以让编译器为final方法生成更高效的代码  
然而，大部分情况下这样做不会对程序的整体性能带来什么改变，因此最好是为了设计使用final，而不是为了提升性能而使用  

向对象发送一条消息，让对象自己做正确的事

对java不适用？？
重载:前期绑定
重写:后期绑定


------------
##构造器和多态
构造器是静态，因此也不是多态的

构造器调用顺序
构造器的调用顺序很重要。当使用继承时，就已经知道了基类的一切，并可以访问基类中任意public和protected的成员  
这意味着在派生类中可以假定所有的基类成员都是有效的，在一个标准方法中，构造动作已经发生过，对象其他部分的所有成员都已经创建好  

销毁  
销毁的顺序应该与初始化的顺序相反，以防一个对象依赖另一个对象  
尽管通常不必进行清理工作，但万一需要时，就得谨慎小心地执行

构造器内部多态方法的行为  
如果在构造器中调用了正在构造的对象的动态绑定方法,可能会带来灾难
构造器的工作就是创建对象（这并非是平常的工作）。在构造器内部，整个对象可能只是部分形成——只知道基类对象已经初始化，
如果构造器只是构造对象过程中的一个步骤，且构造的对象所属的类是从构造器所属的类派生出的，那么派生部分在当前构造器被调用时还没有初始化 
然而，一个动态绑定的方法调用向外深入到继承层次结构中，它可以调用派生类的方法。如果在构造器中这么做，就可能调用一个方法，该方法操纵的成员可能还没有初始化

因此，编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法  
在构造器中唯一能安全调用的只有基类的final方法（包括 private 方法，它们自动属于final），这些方法不能被覆写，因此不会产生意想不到的结果


----------
##协变返回类型
派生类的被覆写方法可以返回基类方法返回类型的派生类型
异常类似


----------
##继承
有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化

纯粹的“is - a"关系：纯粹的替代意味着派生类可以完美地替代基类，子类没有扩展父类
is-like-a关系：子类扩展父类

向下转型，不安全的
在Java中，每次转型都会被检查，即使只是进行一次普通的加括号形式的类型转换，在运行时这个转换仍会被检查，以确保它的确是希望的那种类型   
如果不是就会得到ClassCastException（类转型异常）  
这种在运行时检查类型的行为称作运行时类型信息


----------
多态可能被滥用。仔细分析代码以确保多态确实能带来好处
