#枚举
enum(像接口),具名的值的有限集合，boolean可以看作是一个特例

--------------
--------------
##基本功能
创建enum时，编译器会为你生成一个相关的类，这个类继承自Java.lang.Enum

可以使用==来比较enum实例，编译器会自动为你提供equals()和hashCode()方法。
Enum类实现了Comparable接口，所以它具有compareTo()方法。
同时，它还实现了Serializable接口\
友好支持switch语句
toString()/name(),显示某个enum实例的名称
origin()，编译器创建，表示某个特定enum常量的声明顺序
getDeclaringClass(),获得所属的enum类
static values(),编译器创建，生成这些常量值构成的数组，元素严格保持其在enum中声明时的顺序
static valueOf(一个参数)，是在Enum中定义的static方法，它根据给定的名字返回相应的enum实例
static valueOf(两个参数)，编译器创建

将静态类型导入用于enum

枚举类为final类，所以无法继承自enum


--------------
##添加方法
除了不能继承自一个enum之外，基本上可以将enum看作一个常规的类，同样可以向enum中添加方法

定义自己的方法，那么必须在enum实例序列的最后添加一个分号，Java要求必须先定义enum实例，然后定义方法或属性】

只能在enum定义的内部使用其构造器创建enum实例。一旦enum的定义结束，编译器就不允许我们再使用其构造器来创建任何实例，
最好还是把构造器声明为private

同样也也可以覆盖方法


--------------
##values方法
由于values()方法是由编译器插入到enum定义中的static方法，所以，如果你将enum实例向上转型为Enum，那么 values()方法就不可访问了。
不过，在Class中有一个getEnumConstants0方法，所以即便Enum接口中没values()方法，仍可以通过Class对象取得所有enum实例


--------------
##实现而非继承
所有的enum都继承自Java.lang.Enum类，由于Java不支持多重继承，所以enum不能再继承其他类
创建一个新的enum时，可以同时实现一个或多个接口


-------------
##随机选择
工具类


-------------
##使用接口组织枚举
在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组
对于enum而言，实现接口是使其子类化的唯一办法

更简洁的管理枚举的办法，就是将一个enum嵌套在另一个enum内


-------------
##使用EnumSet替代Flags
Java SE5引入EnumSet(enum看起来也具有集合的行为)
是为了通过enum创建一种替代品，以替代传统的基于int的“位标志”
其内部而言，它（可能）就是将一个 long 值作为比特向量，所以EnumSet非常快速高效
使用EnumSet的优点是，它在说明一个二进制位是否存在时，具有更好的表达能力，并且无需担心性能。

EnumSet的基础是 long，一个long值有 64 位，而一个enum实例只需一位bit表示其是否存在。 
也就是说，在不超过一个long的表达能力的情况下，EnumSet可以应用于最多不超过64个元素的enum。
如果enum超过了64个元素，可能会多使用一个long,性能损失


------------
##使用EnumMap
EnumMap是一种特殊的Map，它要求其中的键（key）必须来自一个enum，由于enum本身的限制，所以EnumMap在内部可由数组实现。
因此 EnumMap的速度很快，可以放心地使用enum实例在EnumMap中进行查找操作。
只能将enum的实例作为键来调用put()可方法，其他操作与使用一般的Map差不多。
EnumMap允许改变值对象


-------------
##应用
命令模式，EnumMap
枚举策略,也叫表驱动的代码（table-driven code)，与使用匿名内部类相比较，定义常量相关方法的语法更高效、简洁。
@TODO
责任链模式 
状态模式
多路分发

-------------
程序员可以将enum与Java语言的其他功能结合使用，例如多态、泛型和反射
说明了一个“小”功能所能带来的价值，有时恰恰因为它才能够优雅而干净地解决问题。
优雅与清晰很重要，正是它们区别了成功的解决方案与失败的解决方案，而失败的解决方案就是因为其他人无法理解它。