#复用
代码复用是面向对象编程（OOP）最具魅力的原因之一
两种代码复用的方法：
1.在新类中创建现有类的对象。这种方式叫做“组合”（Composition），通过这种方式复用代码的功能，而非其形式  
2.创建现有类类型的新类。照字面理解：采用现有类形式，又无需在编码时改动其代码，这种方式就叫做“继承”（Inheritance），编译器会做大部分的工作。继承是面向对象编程（OOP）的重要基础之一

-----------
-----------
##组合
组合 聚合
初始化引用有四种方法:
当对象被定义时。这意味着它们总是在调用构造函数之前初始化  
在该类的构造函数中  
在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次都创建对象的情况下，它可以减少开销  
使用实例初始化

-----------
##继承
super.xxx() 调用方法 xxx()方法的基类版本

必须正确初始化基类子对象，而且只有一种方法可以保证这一点:通过调用基类构造函数在构造函数中执行初始化，该构造函数具有执行基类初始化所需的所有适当信息和特权  
Java自动在派生类构造函数中插入对基类构造函数（无参构造器）的调用
如果复写了构造器(有参数)，又没有添加无参构造器，必须在基类的构造器中显示调用基类适当的构造器，super(xxx)

-----------
#组合与继承的选择
当想在新类中包含一个已有类的功能时，使用组合，而非继承  
也就是说，在新类中嵌入一个对象（通常是私有的），以实现其功能。新类的使用者看到的是所定义的新类的接口，而非嵌入对象的接口  

当使用继承时，使用一个现有类并开发出它的新版本。通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化  

这种“是一个”的关系是用继承来表达的，而“有一个“的关系则用组合来表达

继承中：关键字protected，它表示“就类的用户而言，这是private的，但对于任何继承它的子类或在同一包中的类，它是可访问的（protected也提供了包访问权限）
最好的方式是将属性声明为private以一直保留更改底层实现的权利，然后通过protected控制类的继承者的访问权限

-----------
#委托
虽然Java语言不支持委托，但是开发工具常常支持,eg:Idea

委托类和被委托对象实现相同的接口，委托类方法里实际的执行者都是被委托类


-----------
#final
final通常指的是“不能被改变的”，防止改变有两个原因：设计或效率  
eg:一个永不改变的编译时常量或一个在运行时初始化就不会改变的值  

对于编译时常量这种情况，编译器可以把常量带入计算中；可以在编译时计算，减少了一些运行时的负担  
在Java中，这类常量必须是基本类型，而且用关键字final修饰。必须在定义常量的时候进行赋值  

一个被static和final同时修饰的属性只会占用一段不能改变的存储空间  

当用final修饰对象引用而非基本类型时，对于基本类型，final使数值恒定不变，而对于对象引用，final使引用恒定不变  
但是，对象本身是可以修改的，Java没有提供使任何对象恒定不变的方法（可以自己编写类达到使对象恒定不变的效果）这一限制同样适用数组，数组也是对象 

public static final val = 1; //常量
public意味着可以在包外访问，static强调只有一个，final说明是一个常量

在参数列表中，将参数声明为final意味着在方法中不能改变参数指向的对象或基本变量：

使用final方法的原因有：
1.是给方法上锁，防止子类通过覆写改变方法的行为，主要原因
2.对该方法的调用转化为内嵌调用,提高效率，不一定生效

类中所有的private方法都隐式地指定为final，因为不能访问private方法，所以不能覆写它
可以给private方法添加final修饰，但是并不能给方法带来额外的含义

如果一个方法是private的，它就不是基类接口的一部分，它只是隐藏在类内部的代码，且恰好有相同的命名而已
但是如果在派生类中以相同的命名创建了public，protected 或包访问权限的方法，这些方法与基类中的方法没有联系，没有覆写方法，只是在创建新的方法而已。
由于private方法无法触及且能有效隐藏，除了把它看作类中的一部分，其他任何事物都不需要考虑到它

一个类是final，就意味着它不能被继承，由于final类禁止继承，类中所有的方法都被隐式地指定为final，所以没有办法覆写它们


-----------
#向上转型
多态

继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。简而言之，这种关系可以表述为“新类是已有类的一种类型”  

该术语是基于传统的类继承图：图最上面是根，然后向下铺展，继承图中派生类转型为基类是向上的，所以通常称作向上转型
向上转型永远是安全的


-----------
#类的加载和初始化
每个类的编译代码都存在于它自己独立的文件中，该文件只有在使用程序代码时才会被加载  
一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的static属性或方法，
构造器也是一个static方法尽管它的static关键字是隐式的  
因此，准确地说，一个类当它任意一个static成员被访问时，就会被加载（有些是假象）

首次使用时就是static初始化发生时，所有的static对象和static代码块在加载时按照文本的顺序
（在类中定义的顺序依次初始化，static变量只被初始化一次）


-----------
在清理方法中，还必须注意基类和成员对象清理方法的调用顺序，以防一个子对象依赖于另一个子对象。首先，按与创建的相反顺序执行特定于类的所有清理工作。(一般来说，这要求基类元素仍然是可访问的) 然后调用基类清理方法  

在很多情况下，清理问题不是问题；只需要让垃圾收集器来完成这项工作；但是，当必须执行显式清理时，就需要多做努力，更加细心  
除了内存回收外，不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用 finalize()
