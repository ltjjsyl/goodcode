#异常
发现错误的理想时机是在编译阶段，也就是在试图运行程序之前，然而，编译期间并不能找出所有的错误，余下的问题必须在运行期间解决  
需要错误源能通过某种方式，把适当的信息传递给某个接收者——该接收者将知道如何正确处理这个问题  

----------
----------
##异常概念
异常机制将保证能够捕获错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中，
这种方式不仅节省代码，而且把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离


---------
##基本异常
异常情形（exceptional condition）是指阻止当前方法或作用城继续执行的问题  
把异常情形与普通问题相区分很重要，所谓的普通问题是指在当前环境下能得到足够的信息，总能处理这个错误；
而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题；
所能做的就是从当前环境跳出，并且把问题提交给上一级环境。这就是抛出异常时所发生的事情

当抛出异常后，首先，同Java中其他对象的创建一样，将使用new在堆上创建异常对象；
然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用；
此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序：
这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去 

异常允许强制程序停止运行，并告诉出现了什么问题，或者（理想状态下）强制程序处理问题，并返回到稳定状态  


---------
##异常参数
与使用Java中的其他对象一样，总是用new在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用
所有标准异常类都有两个构造器：一个是默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器

在使用new创建了异常对象之后，此对象的引用将传给throw。尽管返回的异常对象其类型通常与方法设计的返回类型不同，
但从效果上看，它就像是从方法“返回”的。可以简单地把异常处理看成一种不同的返回机制，
另外还能用抛出异常的方式从当前的作用域退出。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域

异常返回的“地点”与普通方法调用返回的“地点”完全不同
（异常将在一个恰当的异常处理程序中得到解决，它的位置可能离异常被抛出的地方很远，也可能会跨越方法调用栈的许多层次）
对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者用异常类的名称来暗示，上一层环境通过这些信息来决定如何处理异常
（通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容）


--------
##异常捕获
监控区域（guarded region）：它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码，使用try块创建  
异常处理程序紧跟在try块之后，以关键字catch表示

每个catch子句（异常处理程序）看起来就像是接收一个且仅接收一个特殊类型的参数的方法，可以在处理程序的内部使用标识符（id1，id2等等），这与方法参数的使用很相似，
有时可能用不到标识符，因为异常的类型已经给了你足够的信息来对异常进行处理，但标识符并不可以省略  
当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入catch子句执行，此时认为异常得到了处理，
一旦catch子句结束，则处理程序的查找过程结束。注意，只有匹配的catch子句才能得到执行；与switch 语句不同  
在try块的内部，许多不同的方法调用可能会产生类型相同的异常，而只需要提供一个针对此类型的异常处理程序

###终止与恢复
异常处理理论上有两种基本模型：终止模型和恢复模型
Java支持终止模型（它是Java和C++所支持的模型）。在这种模型中，将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行。一旦异常被抛出，就表明错误已无法挽回，也不能回来继续执行  
另一种称为恢复模型。意思是异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。对于恢复模型，通常希望异常被处理之后能继续执行程序  
如果想要用Java实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者，把 try块放在while循环里，这样就不断地进入try块，直到得到满意的结果（失败重试机制）
恢复模型不是很实用。其中的主要原因可能是它所导致的耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码。这增加了代码编写和维护的困难


--------
##自定义异常
要自定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承

在异常处理程序中，调用了在Throwable类声明（Exception即从此类继承）的printStackTrace0方法，它将打印“从方法调用处直到异常抛出处”的方法调用序列，
可以手动调用e.printStackTrace();

###异常与记录日志
使用java.util.logging工具将输出记录到日志中


--------
##声明异常
throws
可以声明方法将抛出异常，实际上却不抛出。编译器相信了这个声明，并强制此方法的用户像真的抛出异常那样使用这个方法  
这样做的好处是，为异常先占个位子，以后就可以抛出这种异常而不用修改已有的代码。在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常 

在编译时被强制检查的异常称为被检查的异常
运行时异常


--------
##捕获所有异常
捕获所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了 

Exception是与编程有关的所有异常类的基类，所以它不会含有太多具体的信息，不过可以调用它从其基类Throwable继承的方法：
//用来获取详细信息，或用本地语言表示的详细信息
String getMessage()
String getLocalizedMessage()  

//返回对Throwable的简单描述，要是有详细信息的话，也会把它包含在内
String toString()

//打印Throwable和Throwable的调用栈轨迹,调用栈显示了“把你带到异常抛出地点”的方法调用序列  
//其中第一个版本输出到标准错误，后两个版本允许选择要输出的流
void printStackTrace(PrintStream)
void printStackTrace(java.io.PrintWriter)

//用于在Throwable对象的内部记录栈帧的当前状态,在程序重新抛出错误或异常时很有用
Throwable fillInStackTrace()

也可以使用Throwable从其基类Object继承的方法,对于异常来说，getClass是个很好用的方法，它将返回一个表示此对象类型的对象,  
然后可以使用getName方法查询这个Class对象包含包信息的名称，或者使用只产生类名称的getSimpleName方法


###多重捕获
Java 7的多重捕获机制，可以将不同类型的异常使用“或”将它们组合起来，只在一个catch块中使用
try {
    x();
} catch(Except1 | Except2 | Except3 | Except4 e) {
    process();
}

try {
    x();
} catch(Except1 | Except2 e) {
    process1();
} catch(Except3 | Except4 e) {
    process2();
}

###栈轨迹
printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，
其中每一个元素都表示栈中的一桢,元素0是栈顶元素，并且是调用序列中的最后一个方法调用（这个Throwable 被创建和抛出之处）,数组中的最后一个元素和栈底是调用序列中的第一个方法调用
for(StackTraceElement ste : e.getStackTrace())